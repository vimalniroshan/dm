package com.sparg.java.dm.entity;

import com.sparg.java.dm.annotation.BK;
import com.sparg.java.dm.annotation.FK;
import com.sparg.java.dm.annotation.PK;
import com.sparg.java.dm.annotation.Source;
import com.sparg.java.dm.annotation.Table;
import com.sparg.java.dm.annotation.Target;
import com.sparg.java.dm.util.Utils;
import javassist.util.proxy.MethodFilter;
import javassist.util.proxy.ProxyFactory;
import org.apache.commons.beanutils.BeanUtils;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

/**
 * @author: vimal.sengoden
 * Date: 11/20/2014
 * Time: 5:13 PM
 */
public class EntityManagerImpl<T> implements EntityManager<T> {

    private static final Map<Class, ProxyFactory> proxyFactoryCache = new WeakHashMap<Class, ProxyFactory>();

    public Class<T> entity;
    public Table table;
    public Field primaryKey;
    public boolean pkAutoGenerated;
    public List<Field> bkFields = new ArrayList<Field>();
    public List<Field> fkFields = new ArrayList<Field>();
    public List<Field> sourceFields = new ArrayList<Field>();
    public List<Field> targetFields = new ArrayList<Field>();
    public List<Field> updateTargetFields = new ArrayList<Field>();


    public EntityManagerImpl(final Class<T> entity) {
        this.entity = entity;
        table = EntityUtils.getTable(entity);

        for(Field f : entity.getDeclaredFields()) {
            PK pk = f.getAnnotation(PK.class);
            if(pk != null) {
                primaryKey = f;
                pkAutoGenerated = pk.autoGenerated();
            }
            BK bk = f.getAnnotation(BK.class);
            if(bk != null) {
                bkFields.add(f);
            }
            FK fk = f.getAnnotation(FK.class);
            if(fk != null) {
                fkFields.add(f);
            }
            Source source = f.getAnnotation(Source.class);
            if(source != null) {
                sourceFields.add(f);
            }
            Target t = f.getAnnotation(Target.class);
            if(t != null ) {
                targetFields.add(f);
                if(t.update()) {
                    updateTargetFields.add(f);
                }
            }
        }
    }

    @Override
    public T getNewInstance() throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        ProxyFactory pf = proxyFactoryCache.get(entity);

        if(pf == null) {
            pf = new ProxyFactory();
            pf.setSuperclass(entity);
            pf.setUseCache(true);
            pf.setFilter(new MethodFilter() {
                public boolean isHandled(Method m) {
                    // ignore finalize()
                    return !m.getName().equals("finalize");
                }
            });

            proxyFactoryCache.put(entity, pf);
        }

        return (T) pf.create(new Class[0], new Object[0], getEntityProxy());
    }

    /**
     * This method returns the proxyObject to be attached to each entityRow object.
     * EntityProxy will help to control each row processing by :
     * 1. associating row level meta data
     * 2. tracking row's column value read/write.
     *
     * This method allows you to use different EntityProxy by overriding this.
     *
     * @return
     */
    protected EntityProxy getEntityProxy() {
        return new EntityProxy();
    }

    @Override
    public String getTableName() {
        return table.name();
    }

    @Override
    public Field getPrimaryKey() {
        return primaryKey;
    }

    @Override
    public boolean isPkAutoGenerated(){
        return pkAutoGenerated;
    }

    @Override
    public List<Field> getBkFields() {
        return bkFields;
    }

    @Override
    public List<Field> getFkFields() {
        return fkFields;
    }

    @Override
    public List<Field> getSourceFields() {
        return sourceFields;
    }

    @Override
    public List<Field> getTargetFields() {
        return targetFields;
    }

    @Override
    public List<Field> getUpdateTargetFields() {
        return updateTargetFields;
    }

    /**
     * Retrieve source query provided for entity through @Table.sourceQuery or @Table.sourceQueryFile
     *
     * @return
     */
    public String getSourceQuery() {
        final String query;
        if(!Utils.isEmpty(table.sourceQuery())){
            query = table.sourceQuery();
        } else {
            String sourceQueryFile = null;
            try {
                sourceQueryFile = table.sourceQueryFile();
                query = Utils.getResourceAsString(sourceQueryFile);
            } catch (IOException e) {
                throw new IllegalArgumentException(String.format("Unable to read source query file '%s' of entity %s", sourceQueryFile, entity), e);
            }
        }

        return query;
    }

    /**
     * Create insert query in the format INSERT <table_name> INTO (<column1, column2 ...>) VALUES (?, ?, ?....)
     * Identifies the table name based on the @Table annotation of the class and column name based on @Target annotation of the field
     *
     * @return Returns insert query
     */
    @Override
    public String createInsertQuery() {
        StringBuilder query = new StringBuilder();
        query.append("INSERT INTO ").append(getTableName()).append("(");

        StringBuilder tmp = new StringBuilder();
        List<Field> targetFields = getTargetFields();
        int fieldCount = targetFields.size();
        int commaCount = 0;

        for(Field f : targetFields) {
            query.append(f.getAnnotation(Target.class).name());
            tmp.append("?");
            if(commaCount < fieldCount - 1) {
                query.append(", ");
                tmp.append(", ");
                commaCount++;
            }
        }
        query.append(") VALUES(").append(tmp).append(")");

        return query.toString();
    }

    /**
     * Creates update query in the format UPDATE <table_name> SET <updateField1=?,updateField2=?,..  WHERE <pkField=?>
     * Identifies the table name based on the @Table annotation of the class and column name based on @Target annotation of the field
     *
     * @return Returns update query
     */
    @Override
    public String createUpdateQuery() {
        StringBuilder query = new StringBuilder();

        query.append("UPDATE ").append(getTableName()).append(" SET ");

        List<Field> updateTargetFields = getUpdateTargetFields();
        int fieldCount = updateTargetFields.size();
        int commaCount = 0;
        for(Field f : updateTargetFields) {
            query.append(f.getAnnotation(Target.class).name()).append("=?");
            if(commaCount < fieldCount - 1) {
                query.append(", ");
                commaCount++;
            }
        }

        query.append(" WHERE ");
        query.append(getPrimaryKey().getAnnotation(Target.class).name()).append("=?");

        return query.toString();
    }

    /**
     * Creates delete query in the format DELETE FROM <table_name> WHERE <pkField1=?>
     * Identifies the table name based on the @Table annotation of the class and column name based on @Target annotation of the field
     *
     * @return Returns delete query
     */
    @Override
    public String createDeleteQuery() {
        StringBuilder query = new StringBuilder();

        query.append("DELETE FROM ")
                .append(getTableName())
                .append(" WHERE ")
                .append(getPrimaryKey().getAnnotation(Target.class).name())
                .append("=?");

        return query.toString();
    }

    /**
     * Transforms ResultSet to objects of Entity Class
     *
     * @param rs
     * @return
     * @throws Exception
     */
    @Override
    public Set<T> resultSetToSource(ResultSet rs) throws Exception {
        return resultSetToSource(rs, null, null);
    }

    /**
     * Filter resultSet based on filter and Transforms resultSet to objects of Entity Class
     *
     * @param rs
     * @return
     * @throws Exception
     */
    @Override
    public Set<T> resultSetToSource(ResultSet rs, Filter filter) throws Exception {
        return resultSetToSource(rs, filter, null);
    }

    /**
     * Transforms ResultSet to objects of Entity Class and handle duplicate rows through duplicateHandler
     *
     * @param rs
     * @return
     * @throws Exception
     */
    @Override
    public Set<T> resultSetToSource(ResultSet rs, DuplicateHandler duplicateHandler) throws Exception {
        return resultSetToSource(rs, null, duplicateHandler);
    }

    /**
     * Filters results based on filter provided and Transforms ResultSet to objects of Entity Class
     * and sets only the fields annotated @Source by column name of @Source
     * If the result set has any duplicate, makes a callBack to duplicateHandler
     *
     * @param rs
     * @param filter
     * @param duplicateHandler
     * @return
     * @throws Exception
     */
    @Override
    public Set<T> resultSetToSource(ResultSet rs, Filter filter, DuplicateHandler duplicateHandler) throws Exception{

        Set<T> ts = new HashSet<T>();

        while (rs.next()) {
            if(filter == null || filter.evaluate(rs)) {
                T row = getNewInstance();

                for(Field f : getSourceFields()) {
                    Source c = f.getAnnotation(Source.class);
                    Object value = rs.getObject(c.name());
                    if(value != null) {
                        try {
                            BeanUtils.setProperty(row, f.getName(), value);
                        } catch (Exception e) {
                            throw new RuntimeException("Unable to set property " + f.getName() + " with value " + value, e);
                        }
                    }
                }

                if(!ts.add(row) && null != duplicateHandler) {
                    duplicateHandler.onDuplicate(row);
                }
            }

        }
        return ts;
    }
}
